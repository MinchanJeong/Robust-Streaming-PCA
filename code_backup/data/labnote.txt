hard : rotate옵션 켜서 실제 space간의 distance가 B\Gamma에 가까움.
test : 원래 setting.

< Grid search on parameters >

두 가지 setting: 
setting 1) matrix 일관되게 rotate (+언제나 plane간 distance == gamma) / rotate_type = True
  => 굉장히 작은 크기의 gamma(~1.0e-7,-6)에서 의미있는 결과가 나옴. Theory의 guarantee와 비슷한 regime.
  
setting 2) matrix가 랜덤한 방향으로 rotate / rotate_type = False
  => 상당히 큰 크기의 gamma(~1.0e-2)에서 의미있는 결과가 나옴. 실제 상황과 더 잘 맞는 알고리즘이라고 생각됨.
______________________________
(11/13 01:48)
setting 1
loop = 3
k = 5
sigma = 0.01

순서대로 0   |   1   |   2
p    : 50,     100,    500
delta: 10.0,   3.0,    1.0
gamma: 1.0e-6, 3.0e-6, 1.0e-5  
______________________________

gamma가 첫번째 value빼고는 너무 큰 것 같다
 gamma -> 0 5.0e-7 1.0e-6  2.0e-6 
delta가 1은 너무 작다
 delta -> 10.0 6.0 3.0 1.5
p가 300이어도 너무 오래걸린다
 p ->     50 100 150 200
______________________________
Time 48000 좀 짧다.... 144000으로 늘리자.
p에 대한 다양한 실험이 필요...
(hparams2)
p : 25, 31, 40, 50, 63, 80, 100, 112
gamma : 0, 2.0e-6, 4.0e-6, 6.0e-6, 8.0e-6, 1.0e-5
delta : 1.6, 0.8, 0.4, 0.2
sigma : 0.01
B_list = np.asarray([2,3,8,10,20,30,40,60,80,100,200,300,400,600,800,1000,2000,3000,4000,6000,8000,9600,12000])
______________________________

(hparams3)
다 같이, sigma만 0.1로 조정

______________________________

(11/16 16:50)
(hparams4: sigma=0.01, hparams5: sigma=0.1)
sigma가 0.1이라면 delta 0.2, 0.4 인것 Oja의 convergence 너무 느리다.

parameter:
    delta_list = [1.6, 0.8, 0.4, 0.2]
    gamma_list = [0, 2.0e-6, 4.0e-6, 6.0e-6, 8.0e-6, 1.0e-5]
    B_list = np.asarray([2,3,8,10,20,30,40,60,80,100,200,300,400,600,800,1000,2000,3000,4000,6000,8000,9600,12000])
    p : 50, 60, 70, 80, 90, 100, 110, (120)
    
______________________________
이후에 Gamma 바꾸면서 하는 실험의 경우... 예전처럼 엄청 많은 point를 찍는 것은 아마 어려움이 따를 듯 하다.


